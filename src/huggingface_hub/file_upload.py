import os
from pathlib import Path
from typing import Optional, Union
from urllib.error import HTTPError

import requests

from .utils import logging


logger = logging.get_logger(__name__)


def get_file_size(filename: Union[Path, str]) -> int:
    """
    Return the size of `filename` in bytes
    """
    return os.stat(filename).st_size


def shard_file(
    filename: Union[Path, str],
    shard_size: int = 1024 * 1024,
    save_location: Union[Path, str] = None,
    headers: dict = {},
    identical_ok: bool = True,
    repo_id: str = None,
):
    """
    Splits `filename` into shards of size `shard_size`.
    These split files are then saved to `save_location`.

    If `save_location` is `None`, the save location will be
    the `filename` with `_shards` afterwards.

    Shards are saved with filenames starting from `0` to the total
    number of shards generated.
    """
    urls = []
    size = get_file_size(filename)
    num_shards = int(size / shard_size) + 1
    with open(filename, "rb") as infile:
        for shard_idx in range(num_shards):
            file_bytes = infile.read(shard_size)
            r = requests.post(
                f"{save_location}_shards/{shard_idx}", headers=headers, data=file_bytes
            )
            # Eventually make this more explicit
            try:
                r.raise_for_status()
            except HTTPError as err:
                raise err
            d = r.json()
            if "error" in d:
                logger.error(d["error"])
            urls.append(d.get("url", None))
    return urls


def deshard_file(folder: Union[Path, str], new_file_extension: Optional[str] = None):
    """
    Converts a folder of shards generated by `shard_file` into a single file again.
    The new file is named the same as `folder` with `_shards` removed.

    If an extension is provided the new file will include the extension
    """
    filenames = os.listdir(folder)
    filenames.sort()
    if new_file_extension is not None:
        new_filename = f"{folder}.{new_file_extension}"
    else:
        new_filename = folder
    with open(new_filename, "wb") as outfile:
        for filename in filenames:
            with open(f"{folder}/{filename}", "rb") as infile:
                for line in infile:
                    outfile.write(line)
    return new_filename
